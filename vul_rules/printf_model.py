from pwn import *
import angr	
import claripy
import tqdm
from .simgr_helper import get_trimmed_input
import logging
import copy

log = logging.getLogger(__name__)

def get_max_strlen(state, value):
	i = 0
	for c in value.chop(8):
		i += 1
		if not state.solver.satisfiable([c != 0x00]):
			log.debug("Found the null at offset: {}".format(i))
			return i - 1
		return i

class printFormat(angr.procedures.libc.printf.printf):
    IS_FUNCTION = True
    input_index = 0
    """
    Checks userinput arg
    """

    def __init__(self, input_index):
        # Set user input index for different
        # printf types
        self.input_index = input_index
        angr.procedures.libc.printf.printf.__init__(self)

    def checkExploitable(self, fmt):

        bits = self.state.arch.bits
        load_len = int(bits / 8)
        max_read_len = 1024
        """
        For each value passed to printf
        Check to see if there are any symbolic bytes
        Passed in that we control
        """
        i = self.input_index
        state = self.state
        solv = state.solver.eval

        # fmt_len = self._sim_strlen(fmt)
        # # We control format specifier and strlen isn't going to be helpful,
        # # just set it ourselves
        # if len(state.solver.eval_upto(fmt_len,2)) > 1:
        #     while not state.satisfiable(extra_constraints=[fmt_len == max_read_len]):
        #         max_read_len -=1
        #         if max_read_len < 0:
        #             raise Exception("fmt string with no length!")
        #     state.add_constraints(fmt_len == max_read_len)

        if len(self.arguments) <= i:
            return False
        printf_arg = self.arguments[i]

        var_loc = solv(printf_arg)

        # Parts of this argument could be symbolic, so we need
        # to check every byte
        var_data = state.memory.load(var_loc, max_read_len)
        var_len = get_max_strlen(state, var_data)

        fmt_len = self._sim_strlen(fmt)
        # if len(state.solver.eval_upto(fmt_len,2)) > 1:
        #     state.add_constraints(fmt_len == var_len)

        # Reload with just our max len
        var_data = state.memory.load(var_loc, var_len)

        log.info("Building list of symbolic bytes")
        symbolic_list = [
            state.memory.load(var_loc + x, 1).symbolic for x in range(var_len)
        ]
        log.info("Done Building list of symbolic bytes")

        """
        Iterate over the characters in the string
        Checking for where our symbolic values are
        This helps in weird cases like:

        char myVal[100] = "I\'m cool ";
        strcat(myVal,STDIN);
        printf(myVal);
        """
        position = 0
        count = 0
        greatest_count = 0
        prev_item = symbolic_list[0]
        for i in range(1, len(symbolic_list)):
            if symbolic_list[i] and symbolic_list[i] == symbolic_list[i - 1]:
                count = count + 1
                if count > greatest_count:
                    greatest_count = count
                    position = i - count
            else:
                if count > greatest_count:
                    greatest_count = count
                    position = i - 1 - count
                    # previous position minus greatest count
                count = 0
        log.info(
            "[+] Found symbolic buffer at position {} of length {}".format(
                position, greatest_count
            )
        )

        if greatest_count > 0:
            str_val = b"%lx_"
            if bits == 64:
                str_val = b"%llx_"
            if self.can_constrain_bytes(
                state, var_data, var_loc, position, var_len, strVal=str_val
            ):
                log.info("[+] Can constrain bytes")
                log.info("[+] Constraining input to leak")

                self.constrainBytes(
                    state,
                    var_data,
                    var_loc,
                    position,
                    var_len,
                    strVal=str_val,
                )
                # Verify solution
                # stdin_str = str(state_copy.posix.dumps(0))
                # user_input = self.state.globals["inputType"]
                # if str_val in solv(user_input):
                #     var_value = self.state.memory.load(var_loc)
                #     self.constrainBytes(
                #         self.state, var_value, var_loc, position, var_value_length
                #     )
                # print("[+] Vulnerable path found {}".format(vuln_string))
                user_input = state.globals["user_input"]

                self.state.globals["input"] = solv(user_input, cast_to=bytes)
                self.state.globals["type"] = "Format"
                self.state.globals["position"] = position
                self.state.globals["length"] = greatest_count

                return True

        return False

    def can_constrain_bytes(self, state, symVar, loc, position, length, strVal=b"%x_"):
        total_region = self.state.memory.load(loc, length)
        total_format = strVal * length
        # If we can constrain it all in one go, then let's do it!
        if state.solver.satisfiable(
            extra_constraints=[total_region == total_format[:length]]
        ):
            log.info("Can constrain it all, let's go!")
            state.add_constraints(total_region == total_format[:length])
            return True

        for i in tqdm.tqdm(range(length), total=length, desc="Checking Constraints"):
            strValIndex = i % len(strVal)
            curr_byte = self.state.memory.load(loc + i, 1)
            if not state.solver.satisfiable(
                extra_constraints=[curr_byte == strVal[strValIndex]]
            ):
                return False
        return True

    def constrainBytes(self, state, symVar, loc, position, length, strVal=b"%x_"):

        total_region = self.state.memory.load(loc, length)
        total_format = strVal * length
        # If we can constrain it all in one go, then let's do it!
        if state.solver.satisfiable(
            extra_constraints=[total_region == total_format[:length]]
        ):
            log.info("Can constrain it all, let's go!")
            state.add_constraints(total_region == total_format[:length])
            return

        for i in tqdm.tqdm(range(length), total=length, desc="Constraining"):
            strValIndex = i % len(strVal)
            curr_byte = self.state.memory.load(loc + i, 1)
            if state.solver.satisfiable(
                extra_constraints=[curr_byte == strVal[strValIndex]]
            ):
                state.add_constraints(curr_byte == strVal[strValIndex])
            else:
                log.info(
                    "[~] Byte {} not constrained to {}".format(i, strVal[strValIndex])
                )

    def run(self, _, fmt):
        if not self.checkExploitable(fmt):
            return super(type(self), self).run(fmt)