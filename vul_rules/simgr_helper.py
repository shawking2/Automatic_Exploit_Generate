import claripy
from .radare_helper import findShellcode
from .remote_libc import get_remote_libc_with_leaks
import angr
from pwn import *
import logging


log = logging.getLogger(__name__)

is_printable = False

def check_symbolic_bits(state,val):
    bits = 0
    for idx in range(state.arch.bits):
        if val[idx].symbolic:
            bits += 1
    return bits
 
def print_pc_overflow_msg(state,byte_s):
    print("\n[========find a pc overflow========]")
    print("over for ",hex(byte_s),"bytes")
    print("[PC]stdout:\n",state.posix.dumps(1))
    print("[PC]trigger overflow input:")
    print(state.posix.dumps(0))

def print_bp_overflow_msg(state,byte_s):
    print("\n[========find a bp overflow========]")
    print("over for ",hex(byte_s),"bytes")
    print("[PC]stdout:\n",state.posix.dumps(1))
    print("[PC]trigger overflow input:")
    print(state.posix.dumps(0))
    # print(len(state.posix.dumps(0)))
def check_end(state, simgr):
	try:
		if state.addr==0:
			return

		insns=state.project.factory.block(state.addr).capstone.insns
		if len(insns)>=2:
			flag=0
			#check for : leave; ret;
			for ins in insns:
				if ins.insn.mnemonic=="leave":
					flag+=1
				if ins.insn.mnemonic=="ret":
					flag+=1

			# ins0=insns[0].insn
			# ins1=insns[1].insn
			# if ins0.mnemonic=="leave" and ins1.mnemonic=="ret":
			if flag==2:
				rsp=state.regs.rsp
				rbp=state.regs.rbp
				byte_s=state.arch.bytes
				stack_rbp=state.memory.load(rbp,8,endness=angr.archinfo.Endness.LE)
				stack_ret=state.memory.load(rbp+byte_s,8,endness=angr.archinfo.Endness.LE)
				pre_target=state.callstack.ret_addr
				# print(state.globals['rbp_list'])
				pre_rbp=state.globals['rbp_list'][hex(pre_target)]

				if stack_ret.symbolic:
					num=check_symbolic_bits(state,stack_ret)
					print_pc_overflow_msg(state,num//byte_s)
					state.globals["type"] = "Overflow_pc"
					state.globals["input"] = state.posix.dumps(0)
					state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)
					state.memory.store(rbp+byte_s, state.solver.BVV(pre_target, 64),endness=angr.archinfo.Endness.LE)
					simgr.stashes["found"].append(state)
					simgr.stashes["active"].remove(state)
					return simgr



				if stack_rbp.symbolic:
					num=check_symbolic_bits(state,stack_rbp)
					print_bp_overflow_msg(state,num//byte_s)
					state.globals["type"] = "Overflow_bp"
					state.globals["input"] = state.posix.dumps(0)
					state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)
					simgr.stashes["found"].append(state)
					simgr.stashes["active"].remove(state)
					return simgr
	except:
		return

def check_head(state, simgr):
   
    # if ((state.addr / 0x400000) >=1) :
    try:
        insns=state.project.factory.block(state.addr).capstone.insns
        
        # print(len(insns))
        if len(insns) >=3:
            #check for : endbr64, push rbp; mov rsp,rbp;
            ins0 = insns[0].insn
            ins1=insns[1].insn
            ins2=insns[2].insn
            if len(ins1.operands)==1 and len(ins2.operands)==2 and len(ins0.operands) == 0:
                # print(insns)
                ins0_name = ins0.mnemonic #endbr64
                ins1_name=ins1.mnemonic#push 
                ins1_op0=ins1.reg_name(ins1.operands[0].reg)#rbp
                ins2_name=ins2.mnemonic#mov 
                ins2_op0=ins2.reg_name(ins2.operands[0].reg)#rsp
                ins2_op1=ins2.reg_name(ins2.operands[1].reg)#rbp

                if ins0_name == "endbr64" and ins1_name=="push" and ins1_op0=="rbp" and ins2_name=="mov" and ins2_op0=="rbp" and ins2_op1=="rsp":
                    # print("find a function head,save the rsp,rbp")
                    pre_target=state.callstack.ret_addr
                    state.globals['rbp_list'][hex(pre_target)]=state.regs.rbp
        elif len(insns) >=2:
            #check for : push rbp; mov rsp,rbp; 
            ins0=insns[0].insn
            ins1=insns[1].insn
            if len(ins0.operands)==1 and len(ins1.operands)==2:
                # print(insns)
                ins0_name=ins0.mnemonic#push 
                ins0_op0=ins0.reg_name(ins0.operands[0].reg)#rbp
                ins1_name=ins1.mnemonic#mov 
                ins1_op0=ins1.reg_name(ins1.operands[0].reg)#rsp
                ins1_op1=ins1.reg_name(ins1.operands[1].reg)#rbp

                if ins0_name=="push" and ins0_op0=="rbp" and ins1_name=="mov" and ins1_op0=="rbp" and ins1_op1=="rsp":
                    # print("find a function head,save the rsp,rbp")
                    pre_target=state.callstack.ret_addr
                    state.globals['rbp_list'][hex(pre_target)]=state.regs.rbp
    except:
        return

def overflow_detect_filter(simgr):
	while simgr.active:
		for state in simgr.active:
			if state.globals.get("type", None) == "overflow_variable":
				log.info("Found vulnerable state. Overflow variable to win")
				user_input = state.globals["user_input"]
				input_bytes = state.solver.eval(user_input, cast_to=bytes)
				log.info("[+] Vulnerable path found {}".format(input_bytes))
				state.globals["type"] = "overflow_variable"
				state.globals["input"] = input_bytes
				simgr.stashes["found"].append(state)
				simgr.stashes["active"].remove(state)
				return simgr
			check_head(state, simgr)
			check_end(state, simgr)
		simgr.step()

	# for state in simgr.unconstrained:
	# 	bits = state.arch.bits
	# 	num_count = bits / 8
	# 	# print(num_count)
	# 	pc_value = b"C" * int(num_count)

	# # Check satisfiability
	# 	if state.solver.satisfiable(extra_constraints=[state.regs.pc == pc_value]):

	# 		state.add_constraints(state.regs.pc == pc_value)
	# 		user_input = state.globals["user_input"]
 
	# 		log.info("Found vulnerable state.")

	# 		if is_printable:
	# 			log.info("Constraining input to be printable")
	# 			for c in user_input.chop(8):
	# 				constraint = claripy.And(c > 0x2F, c < 0x7F)
	# 				if state.solver.satisfiable([constraint]):
	# 					state.add_constraints(constraint)

	# 		# Get input values
	# 		input_bytes = state.solver.eval(user_input, cast_to=bytes)
	# 		log.info("[+] Vulnerable path found {}".format(input_bytes))
	# 		if b"CCCC" in input_bytes:
	# 			log.info("[+] Offset to bytes : {}".format(input_bytes.index(b"CCCC")))
	# 		state.globals["type"] = "Overflow"
	# 		state.globals["input"] = input_bytes
	# 		simgr.stashes["found"].append(state)
	# 		simgr.stashes["unconstrained"].remove(state)
	# 		break

	# return simgr
class hook_win(angr.SimProcedure):
    IS_FUNCTION = True

    good_strings = [b"/bin/sh", b"/bin/bash", b"/bin/dash"]

    def run(self):

        if self.state.arch.bits == 64:
            cmd_ptr = self.state.regs.rdi
        if self.state.arch.bits == 32:
            # First arg pushed to the stack
            cmd_ptr = self.state.memory.load(self.state.regs.sp - 4, 4)
        cmd_str = self.state.memory.load(cmd_ptr, 32)

        arg = self.state.solver.eval(cmd_str, cast_to=bytes)

        log.info("system() called with {}".format(arg))
        if any(x in arg for x in self.good_strings):
            # Win!
            self.state.globals["type"] = "overflow_variable"


class hook_four(angr.SimProcedure):
    IS_FUNCTION = True

    def run(self):
        return 4  # Fair dice roll
def get_trimmed_input(user_input, state):
	trim_index = -1
	index = 0
	for c in user_input.chop(8):
		num_constraints = get_num_constraints(c, state)
		if num_constraints == 0 and trim_index == -1:
			trim_index = index
		else:
			trim_index == -1
		index += 1
	input_bytes = state.solver.eval(user_input, cast_to=bytes)

	if trim_index > 0:
		log.debug("Found input without constraints starting at {}".format(trim_index))
		return input_bytes[:trim_index]
	return input_bytes


