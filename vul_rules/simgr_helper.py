import claripy
from .radare_helper import findShellcode
from .remote_libc import get_remote_libc_with_leaks
import angr
from pwn import *
import logging


log = logging.getLogger(__name__)

is_printable = False

def overflow_detect_filter(simgr):
	for state in simgr.active:
		if state.globals.get("type", None) == "overflow_variable":
			log.info("Found vulnerable state. Overflow variable to win")
			user_input = state.globals["user_input"]
			input_bytes = state.solver.eval(user_input, cast_to=bytes)
			log.info("[+] Vulnerable path found {}".format(input_bytes))
			state.globals["type"] = "overflow_variable"
			state.globals["input"] = input_bytes
			simgr.stashes["found"].append(state)
			simgr.stashes["active"].remove(state)
			return simgr

	for state in simgr.unconstrained:
		bits = state.arch.bits
		num_count = bits / 8
		# print(num_count)
		pc_value = b"C" * int(num_count)

	# Check satisfiability
		if state.solver.satisfiable(extra_constraints=[state.regs.pc == pc_value]):

			state.add_constraints(state.regs.pc == pc_value)
			user_input = state.globals["user_input"]

			log.info("Found vulnerable state.")

			if is_printable:
				log.info("Constraining input to be printable")
				for c in user_input.chop(8):
					constraint = claripy.And(c > 0x2F, c < 0x7F)
					if state.solver.satisfiable([constraint]):
						state.add_constraints(constraint)

			# Get input values
			input_bytes = state.solver.eval(user_input, cast_to=bytes)
			log.info("[+] Vulnerable path found {}".format(input_bytes))
			if b"CCCC" in input_bytes:
				log.info("[+] Offset to bytes : {}".format(input_bytes.index(b"CCCC")))
			state.globals["type"] = "Overflow"
			state.globals["input"] = input_bytes
			simgr.stashes["found"].append(state)
			simgr.stashes["unconstrained"].remove(state)
			break

	return simgr
class hook_win(angr.SimProcedure):
    IS_FUNCTION = True

    good_strings = [b"/bin/sh", b"/bin/bash", b"/bin/dash"]

    def run(self):

        if self.state.arch.bits == 64:
            cmd_ptr = self.state.regs.rdi
        if self.state.arch.bits == 32:
            # First arg pushed to the stack
            cmd_ptr = self.state.memory.load(self.state.regs.sp - 4, 4)
        cmd_str = self.state.memory.load(cmd_ptr, 32)

        arg = self.state.solver.eval(cmd_str, cast_to=bytes)

        log.info("system() called with {}".format(arg))
        if any(x in arg for x in self.good_strings):
            # Win!
            self.state.globals["type"] = "overflow_variable"


class hook_four(angr.SimProcedure):
    IS_FUNCTION = True

    def run(self):
        return 4  # Fair dice roll